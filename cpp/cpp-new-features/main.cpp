#include <iostream>
#include <chrono>

template<unsigned n>
struct Fibonacci {
    static const unsigned value = Fibonacci<n - 1>::value + Fibonacci<n - 2>::value;
};

template<>
struct Fibonacci<0> {
    static const unsigned value = 0;
};

template<>
struct Fibonacci<1> {
    static const unsigned value = 1;
};

template<typename... arguments>
auto SumWithOne(arguments... args) {
    return (1+ ... + args);
}

int sumOfAPair(std::pair<int, int> p) {
    return p.first + p.second;
}

namespace A::B::C { std::string test = "This is a string defined in a nested namespace"; }

template<auto value>
void f() {}

auto formula(int a) {
    return a * 2 + 0.1;
}

auto anySum = [](auto a, auto b) { return a + b; };

auto timer = [val = std::chrono::system_clock::now()] { return std::chrono::system_clock::now() - val; };

template<typename T>
constexpr T pi = T(3.1415926535897932385);

int main() {
    std::cout << "8th element of Fibonacci generated by templates at compile time: " << Fibonacci<8>::value
              << std::endl;
    auto a = {1, 2, 3};
    std::cout << "The first elemetn of initizer list: " << *std::begin(a);
    // The following should work in CPP 17
    //auto b = {1};
    //std::cout << b;

    auto test = SumWithOne(1, 2, 3, 4);
    std::cout << "The results of compact variadic template usage: " << test << std::endl;

    std::cout << A::B::C::test << std::endl;

    std::cout << "Template argument deduction for class templates: " << sumOfAPair(std::pair(3, 4)) << std::endl;

    f<10>();

    std::cout << "Automatic return type deduction for functions:" << formula(10) << std::endl;

    std::cout << "Generic lambdas:" << anySum(1.5,2) << std::endl;

    std::cout << "Lambda capturing initialization"; timer();
    return 0;
}