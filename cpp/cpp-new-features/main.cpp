#include <iostream>

template<unsigned n>
struct Fibonacci {
    static const unsigned value = Fibonacci<n - 1>::value + Fibonacci<n - 2>::value;
};

template<>
struct Fibonacci<0> {
    static const unsigned value = 0;
};

template<>
struct Fibonacci<1> {
    static const unsigned value = 1;
};

template <typename... arguments>
auto SumWithOne(arguments... args) {
    return (1+ ... + args);
}

int sumOfAPair(std::pair<int, int> p) {
    return p.first + p.second;
}

namespace A::B::C { std::string test = "This is a string defined in a nested namespace"; }

template <auto value> void f() {}



int main() {
    std::cout <<  "8th element of Fibonacci generated by templates at compile time: "  << Fibonacci<8>::value << std::endl;
    auto a = {1,2,3};
    std::cout << "The first elemetn of initizer list: " << *std::begin(a);
    // The following should work in CPP 17
    //auto b = {1};
    //std::cout << b;

    auto test = SumWithOne(1,2,3,4);
    std::cout << "The results of compact variadic template usage: " << test << std::endl;

    std::cout << A::B::C::test << std::endl;

    std::cout << "Template argument deduction for class templates: " << sumOfAPair(std::pair(3,4)) << std::endl;

    f<10>();
    return 0;
}